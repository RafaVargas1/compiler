package parsers;

import token.*;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class MiniLangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pDapapGr4Kn$$lFI689GH9x6BVPIOplW6D6QtFeDFfqkbqEXsLZaQdeD9eD7O6C$PzZ#N" +
		"wlymXZtb9J3GvRtxdd7lEkU$k01G2Q4GDQb67UZIW55xuKO4gP28VBIX66pfIgEc20LqTAP" +
		"Mana5TcAJ6HLqKlqQzCb#23BWJ$2UTMbcM7OnvsMYsZNVRHl$gEP6B7EIX01wKmOToLA8QJ" +
		"MX5EphH0mqwTpY3vv39UJavYnpsSB57FliKSa#BKgZnSvmAZeIaDQR#NuqdclTmnV5hqgbL" +
		"Ojd1cAVprjh5VRRHlteQRq8npzt$wzF40i4meX8WNMIGX2GsJIx98jaX6wIFR4f#M55e1yY" +
		"Gn4Q8M$nHia3CvX8P8yjadAoG2R8QbeBVK2R9dFWHiLDaZSoGRJ9FPic#vDsM$e44$mvP$7" +
		"NIA7wlM7Ej$U9$hNTBxBRO7R6xySQH$9vDx6k#1vROeTWWHDIx#i0FKM$VNYIgNyWTkIKtv" +
		"9fSgKjreSxLcJfL9z6gO$9CdiYZkgT#ODZB5whnVHb4vnjo4eCunEeMpBPvQmmRj3WOgFe4" +
		"kokO9G==");

	private final Action[] actions;

	public MiniLangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] Prog = StmtList.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					 return s;
				}
			},
			new Action() {	// [1] StmtList = Stmt.s SEMI StmtList.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final Node l = (Node) _symbol_l.value;
					 return new StmtList(s, l);
				}
			},
			new Action() {	// [2] StmtList = Stmt.s SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Node s = (Node) _symbol_s.value;
					 return s;
				}
			},
			new Action() {	// [3] Stmt = DATA TYPE.t ID.i OPENPARENTHESIS CLOSEPARENTHESIS OPENKEYS StmtList.l CLOSEKEYS
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol t = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final Node l = (Node) _symbol_l.value;
					 return new Data(t, i, l);
				}
			},
			new Action() {	// [4] Stmt = IF Expr.e Stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final Node s = (Node) _symbol_s.value;
					 return new If(e, s);
				}
			},
			new Action() {	// [5] Stmt = IF Expr.e Stmt.s ELSE Stmt.s2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final Node s = (Node) _symbol_s.value;
					final Symbol _symbol_s2 = _symbols[offset + 5];
					final Node s2 = (Node) _symbol_s2.value;
					 return new IfElse(e, s, s2);
				}
			},
			new Action() {	// [6] Stmt = ITERATE Expr.e Stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final Node s = (Node) _symbol_s.value;
					 return new Iterate(e, s);
				}
			},
			new Action() {	// [7] Stmt = READ ID.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					 return new Read(i);
				}
			},
			new Action() {	// [8] Stmt = PRINT Expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new Print(e);
				}
			},
			new Action() {	// [9] Stmt = RETURN Expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new Return(e);
				}
			},
			new Action() {	// [10] Stmt = Expr.e ATRIBUITION Expr.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final Expr v = (Expr) _symbol_v.value;
					 return new Assignment(e, v);
				}
			},
			new Action() {	// [11] Stmt = Expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return e;
				}
			},
			new Action() {	// [12] Expr = Expr.a PLUS Expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a, b);
				}
			},
			new Action() {	// [13] Expr = Expr.a MINUS Expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a, b);
				}
			},
			new Action() {	// [14] Expr = Expr.a MULTI Expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a, b);
				}
			},
			new Action() {	// [15] Expr = Expr.a DIVIDE Expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a, b);
				}
			},
			new Action() {	// [16] Expr = Expr.a AND Expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new And(a, b);
				}
			},
			new Action() {	// [17] Expr = INTEGER.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final Integer i = (Integer) _symbol_i.value;
					 return new IntegerLiteral(i);
				}
			},
			new Action() {	// [18] Expr = FLOATVAR.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_f = _symbols[offset + 1];
					final Float f = (Float) _symbol_f.value;
					 return new FloatLiteral(f);
				}
			},
			new Action() {	// [19] Expr = CHARACTER.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final Character c = (Character) _symbol_c.value;
					 return new CharLiteral(c);
				}
			},
			new Action() {	// [20] Expr = ID.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new Variable(i);
				}
			},
			new Action() {	// [21] Expr = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new BooleanLiteral(true);
				}
			},
			new Action() {	// [22] Expr = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new BooleanLiteral(false);
				}
			},
			new Action() {	// [23] Expr = OPENPARENTHESIS Expr.e CLOSEPARENTHESIS
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
