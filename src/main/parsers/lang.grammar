%package "parsers";
%import "token.*";

%class "MiniLangParser";

%terminals DATA, IF, ELSE, ITERATE, READ, PRINT, RETURN, NEW, TRUE, FALSE, NULL,
           INT, FLOAT, CHAR, BOOL, 
           ID, TYPE, FLOATVAR, INTEGER, CHARACTER,
           OPENPARENTHESIS, CLOSEPARENTHESIS, OPENKEYS, CLOSEKEYS,
           OPENBRACKETS, CLOSEBRACKETS, EQUAL, ATRIBUITION, GREATER, SMALLER,
           DIFFERENT, PLUS, MINUS, MULTI, DIVIDE, INTDIVIDE, AND, DOT, DOUBLEDOTDOT, 
           DOTDOT, COMMA, SEMI, NEGATION;
           
%typeof INTEGER = "Integer";
%typeof FLOATVAR = "Float";
%typeof CHARACTER = "Character";
%typeof ID = "String";
%typeof Expr = "Expr";
%typeof Stmt = "Node";
%typeof StmtList = "Node";
%typeof Prog = "Node";

%goal Prog;  

Prog = StmtList.s                     {: return s; :} 
    ;

StmtList = Stmt.s SEMI StmtList.l     {: return new StmtList(s, l); :}
        | Stmt.s SEMI                 {: return s; :} 
        ;

Stmt = DATA TYPE.t ID.i OPENPARENTHESIS CLOSEPARENTHESIS OPENKEYS StmtList.l CLOSEKEYS  {: return new Data(t, i, l); :}
    | IF Expr.e Stmt.s               {: return new If(e, s); :}
    | IF Expr.e Stmt.s ELSE Stmt.s2  {: return new IfElse(e, s, s2); :}
    | ITERATE Expr.e Stmt.s          {: return new Iterate(e, s); :}
    | READ ID.i                      {: return new Read(i); :}
    | PRINT Expr.e                   {: return new Print(e); :}
    | RETURN Expr.e                  {: return new Return(e); :}
    | Expr.e ATRIBUITION Expr.v      {: return new Assignment(e, v); :}
    | Expr                           {: return e; :}
    ;

Expr = Expr.a PLUS Expr.b             {: return new Add(a, b); :}
    | Expr.a MINUS Expr.b            {: return new Sub(a, b); :}
    | Expr.a MULTI Expr.b            {: return new Mul(a, b); :}
    | Expr.a DIVIDE Expr.b           {: return new Div(a, b); :}
    | Expr.a AND Expr.b              {: return new And(a, b); :}
    | INTEGER.i                      {: return new IntegerLiteral(i); :}
    | FLOATVAR.f                     {: return new FloatLiteral(f); :}
    | CHARACTER.c                    {: return new CharLiteral(c); :}
    | ID.i                           {: return new Variable(i); :}
    | TRUE                           {: return new BooleanLiteral(true); :}
    | FALSE                          {: return new BooleanLiteral(false); :}
    | OPENPARENTHESIS Expr.e CLOSEPARENTHESIS {: return e; :}
    ;