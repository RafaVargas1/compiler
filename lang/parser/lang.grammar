//Arthur Vieira da Silva    - 202035013
//Rafael de Oliveira Vargas - 202035022

%package "lang.parser";
%import "lang.ast.*";

%class "LangParser";

%terminals  DATA, IF, ELSE, ITERATE, READ, PRINT, RETURN, NEW, TRUE, FALSE, NULL,
            INT, FLOAT, CHAR, BOOL,
            ID, TYPE, INTEGER, FLOATVAR, CHARACTER,
            OPENPARENTHESIS, CLOSEPARENTHESIS, OPENKEYS, CLOSEKEYS, OPENBRACKETS, CLOSEBRACKETS,
            ATRIBUITION, GREATER, SMALLER, EQUAL, DIFFERENT, PLUS, MINUS, MULTI, DIVIDE, INTDIVIDE,
            AND, DOT, DOTDOT, DOUBLEDOTDOT, COMMA, SEMI, NEGATION;

%left CLOSEBRACKETS, DOT, CLOSEPARENTHESIS;
%right NEGATION, UNARY_MINUS;
%left MULTI, DIVIDE, INTDIVIDE;
%left PLUS, MINUS;
%left GREATER, SMALLER;
%left EQUAL, DIFFERENT;
%left AND;
%left ELSE;

%typeof ID               =    "String";
%typeof TYPE             =    "String";
%typeof INTEGER          =    "Integer";
%typeof FLOATVAR         =    "Float";
%typeof CHARACTER        =    "String";

%typeof Prog             =    "Program";
%typeof Data             =    "Node";
%typeof Fun              =    "Node";
%typeof Decl             =    "Param";
%typeof Type             =    "Node";
%typeof Cmd              =    "Node";
%typeof Param            =    "Param";
%typeof Expr             =    "Expr";
%typeof Value            =    "Expr";
%typeof ElseCmd          =    "Node";
%typeof ArrayDefiner     =    "Expr";
%typeof Def              =    "Node";
%typeof Return           =    "NodeList";
%typeof TypeList         =    "NodeList";
%typeof CmdList          =    "NodeList";
%typeof ValueList        =    "NodeList";
%typeof Values           =    "NodeList";

%goal Prog;

Prog = Def.l+                                                                                                 {: return new Program(l); :}
     ;

Def = Data.d                                                                                                  {: return d; :}                                                                                                  
    | Fun.f                                                                                                   {: return f; :}   
    ;

Data = DATA TYPE.i OPENKEYS DeclList.l CLOSEKEYS                                                              {: return new Data(i, l); :} 
     ;

DeclList = DeclList Decl                                                                                  
         | Decl                                                                                                                 
         ;

Decl = ID.i DOUBLEDOTDOT Type.t SEMI                                                                          {: return new Param(i, t); :} 
     ;

Fun = ID.i OPENPARENTHESIS ParamsList.p? CLOSEPARENTHESIS Return.r? OPENKEYS CmdList.c? CLOSEKEYS             {: return new Function(i, p, r, c); :}
    ;     

ParamsList = Param                                                                                          
           | ParamsList COMMA Param                                                                            
           ;

Param = ID.i DOUBLEDOTDOT Type.t                                                                              {: return new Param(i, t); :}
      ;

Return = DOTDOT TypeList.l                                                                                    {: return l; :}
       ;

TypeList = Type.t                                                                                             {: return new NodeList(t); :}                                                                      
         | TypeList.l COMMA Type.t                                                                            {: return new NodeList(t, l); :}                                                           
         ;

Type = Type.t OPENBRACKETS CLOSEBRACKETS                                                                      {: return new Vector(t); :}
     | Literal.l                                                                                              {: return l; :}
     ;

Literal = INT                                                                                                 {: return new IntType(); :}
        | CHAR                                                                                                {: return new CharType(); :}
        | BOOL                                                                                                {: return new BoolType(); :}
        | FLOAT                                                                                               {: return new FloatType(); :}
        | TYPE.i                                                                                              {: return new DataType(i); :}
        ;

Cmd = OPENKEYS CmdList.l? CLOSEKEYS                                                                           {: return l; :}
    | IF OPENPARENTHESIS Expr.e CLOSEPARENTHESIS Cmd.t ElseCmd.f?                                             {: return new If(e, t, f); :}
    | ITERATE OPENPARENTHESIS Expr.e CLOSEPARENTHESIS Cmd.c                                                   {: return new Iterate(e, c); :}
    | READ Value.v SEMI                                                                                       {: return new Read(v); :}
    | PRINT Expr.e SEMI                                                                                       {: return new Print(e); :}
    | RETURN ReturnList.l SEMI                                                                                {: return new Return(l); :}
    | Value.v ATRIBUITION Expr.e SEMI                                                                         {: return new Atribuition(v, e); :}
    | ID.i OPENPARENTHESIS ExprList.l? CLOSEPARENTHESIS ValueList.v? SEMI                                     {: return new Call(i, l, v); :}
    ;

ElseCmd = ELSE Cmd.c                                                                                          {: return c; :}
        ;

CmdList = CmdList.l Cmd.c                                                                                     {: return new NodeList(c, l); :}
        | Cmd.c                                                                                               {: return new NodeList(c); :}
        ;

ReturnList = Expr                                                                                           
           | ReturnList COMMA Expr                                                                        
           ;

ValueList = SMALLER Values.v GREATER                                                                          {: return v; :}                                                                       
          ;

Values = Value.v                                                                                              {: return new NodeList(v); :}                                                                        
       | Values.l COMMA Value.v                                                                               {: return new NodeList(v, l); :}                                       
       ;
          
Expr = Expr.e1 AND Expr.e2                                                                                    {: return new And(e1, e2); :}
     | Expr.e1 SMALLER Expr.e2                                                                                {: return new Smaller(e1, e2); :}
     | Expr.e1 GREATER Expr.e2                                                                                {: return new Greater(e1, e2); :}
     | Expr.e1 EQUAL Expr.e2                                                                                  {: return new Equal(e1, e2); :}
     | Expr.e1 DIFFERENT Expr.e2                                                                              {: return new Different(e1, e2); :}
     | Expr.e1 PLUS Expr.e2                                                                                   {: return new Addition(e1, e2); :}
     | Expr.e1 MINUS Expr.e2                                                                                  {: return new Subtraction(e1, e2); :}
     | Expr.e1 MULTI Expr.e2                                                                                  {: return new Multiplication(e1, e2); :}
     | Expr.e1 DIVIDE Expr.e2                                                                                 {: return new Division(e1, e2); :}
     | Expr.e1 INTDIVIDE Expr.e2                                                                              {: return new Mod(e1, e2); :}
     | NEGATION Expr.e                                                                                        {: return new Not(e); :}
     | MINUS Expr.e @ UNARY_MINUS                                                                             {: return new Negative(e); :}
     | TRUE                                                                                                   {: return new True(); :}
     | FALSE                                                                                                  {: return new False(); :}
     | NULL                                                                                                   {: return new Null(); :}
     | INTEGER.i                                                                                              {: return new IntegerVar(i); :}
     | FLOATVAR.f                                                                                             {: return new FloatVar(f); :}
     | CHARACTER.c                                                                                            {: return new CharacterVar(c); :}
     | Value.v                                                                                                {: return v; :}
     | OPENPARENTHESIS Expr.e CLOSEPARENTHESIS                                                                {: return e; :}
     | NEW Type.t ArrayDefiner.e?                                                                             {: return new Instance(t, e); :}
     | ID.i OPENPARENTHESIS ExprList.l? CLOSEPARENTHESIS OPENBRACKETS Expr.e CLOSEBRACKETS                    {: return new IndexedCall(i, l, e); :}
     ;

ArrayDefiner = OPENBRACKETS Expr.e CLOSEBRACKETS                                                              {: return e; :}
             ;

ExprList = Expr                                                                                             
         | ExprList COMMA Expr                                                                            
         ;
         
Value = ID.i                                                                                                  {: return new ID(i); :}
      | Value.v OPENBRACKETS Expr.e CLOSEBRACKETS                                                             {: return new Array(v, e); :}
      | Value.v DOT ID.i                                                                                      {: return new Component(v, i); :}
      ;