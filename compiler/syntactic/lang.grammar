%package "syntactic";
%import "ast.*";

%class "LangParser";

%terminals  DATA, IF, ELSE, ITERATE, READ, PRINT, RETURN, NEW, TRUE, FALSE, NULL,
            INT, FLOAT, CHAR, BOOL,
            ID, TYPE, INTEGER, FLOATVAR, CHARACTER,
            OPENPARENTHESIS, CLOSEPARENTHESIS, OPENKEYS, CLOSEKEYS, OPENBRACKETS, CLOSEBRACKETS,
            ATRIBUITION, GREATER, SMALLER, EQUAL, DIFFERENT, PLUS, MINUS, MULTI, DIVIDE, INTDIVIDE,
            AND, DOT, DOTDOT, DOUBLEDOTDOT, COMMA, SEMI, NEGATION,
            EOF;

%left CLOSEBRACKETS, DOT, CLOSEPARENTHESIS;
%right NEGATION, UNARY_MINUS;
%left MULTI, DIVIDE, INTDIVIDE;
%nonassoc PLUS, MINUS;
%nonassoc GREATER, SMALLER;
%left EQUAL, DIFFERENT;
%left AND;

%typeof DefList = "Node";
%typeof Def = "Node";
%typeof Data = "Node";
%typeof Fun = "Node";
%typeof ID = "String";
%typeof DeclList = "Node";
%typeof Decl = "Node";
%typeof Type = "";
%typeof ParamsOpt = "";
%typeof ReturnOpt = "";
%typeof Cmd = "Node";
%typeof CmdOpt = "Node";
%typeof ParamsList = "Node";
%typeof Param = "Node";
%typeof ReturnType = "";
%typeof Literal = "";
%typeof Expr = "Expr";
%typeof Value = "";
%typeof ReturnList = "";
%typeof ExprListOpt = "";
%typeof ValueListOpt = "";
%typeof ValueList = "";
%typeof INTEGER = "Integer";
%typeof FLOATVAR = "Float";
%typeof CHARACTER = "String";
%typeof ExprOpt = "";
%typeof Prog = "Node";

%goal Prog;

Prog = DefList.l                                       {: return l; :}
     ;

DefList = Def.d SEMI DefList.l                         {: return new NodeList(d, l); :}
        | Def.d SEMI                                   {: return d; :}                      
        ;

Def = Data.d                                           {: return d; :}
    | Fun.f                                            {: return f; :}
    ;

Data = DATA ID.i OPENKEYS DeclList.l CLOSEKEYS           
     ;

DeclList = Decl.d DeclList.l                           {: return new ParamList(d, l); :}
         | Decl.d                                      {: return d; :}                        
         ;

Decl = ID.i DOUBLEDOTDOT Type.t SEMI                      {: return new Param(i, t); :} 
     ;

Fun = ID.i OPENPARENTHESIS ParamsOpt.p CLOSEPARENTHESIS ReturnOpt.r OPENKEYS Cmd.c CLOSEKEYS
    ;     

ParamsOpt = ParamsList.l                               {: return l; :}
          |                                            {: return; :}
          ;

ParamsList = Param.p                                   {: return p; :}    
           | Param.p COMMA ParamsList.l                {: return new ParamList(p, l); :}     
           ;

Param = ID.i DOUBLEDOTDOT Type.t                       {: return new Param(i, t); :}
      ;

ReturnOpt = ReturnType.r
          |
          ;

ReturnType = DOTDOT Type.t
           | DOTDOT Type.t COMMA ReturnType.r
           ;

Type = Type.t OPENBRACKETS CLOSEBRACKETS
     | Literal.l
     ;

Literal = INT
        | CHAR
        | BOOL
        | FLOAT
        | ID.i
        ;

CmdOpt = Cmd.c
       |
       ;

Cmd = OPENKEYS CmdOpt.c CLOSEKEYS    
    | IF OPENPARENTHESIS Expr.e CLOSEPARENTHESIS Cmd.c
    | IF OPENPARENTHESIS Expr.e CLOSEPARENTHESIS Cmd.t ELSE Cmd.f
    | ITERATE OPENPARENTHESIS Expr.e CLOSEPARENTHESIS Cmd.c
    | READ Value.v SEMI
    | PRINT Expr.e SEMI
    | RETURN ReturnList.l SEMI
    | Value.v ATRIBUITION Expr.e SEMI
    | ID.i OPENPARENTHESIS ExprListOpt.l CLOSEPARENTHESIS ValueListOpt.v SEMI
    ;

ReturnList = Expr.e
           | Expr.e COMMA ReturnList.l
           ;

ValueListOpt = ValueList.l
             |
             ;

ValueList = SMALLER Value.v GREATER
          | SMALLER Value.v COMMA ValueList.l GREATER
          ;
          
Expr = Expr.e1 AND Expr.e2
     | Expr.e1 SMALLER Expr.e2
     | Expr.e1 GREATER Expr.e2
     | Expr.e1 EQUAL Expr.e2
     | Expr.e1 DIFFERENT Expr.e2
     | Expr.e1 PLUS Expr.e2
     | Expr.e1 MINUS Expr.e2
     | Expr.e1 MULTI Expr.e2
     | Expr.e1 DIVIDE Expr.e2
     | Expr.e1 INTDIVIDE Expr.e2
     | NOT Expr.e
     | MINUS Expr.e @ UNARY_MINUS
     | TRUE
     | FALSE
     | NULL
     | INTEGER.i
     | FLOATVAR.f
     | CHARACTER.c
     | Value.v
     | OPENPARENTHESIS Expr.e CLOSEPARENTHESIS
     | NEW Type.t ExprOpt.e
     | ID.i OPENPARENTHESIS ExprListOpt.l CLOSEPARENTHESIS OPENBRACKETS Expr.e CLOSEBRACKETS
     ;

ExprOpt = OPENBRACKETS Expr.e CLOSEBRACKETS
        |
        ;

ExprListOpt = ExprList.l
            |
            ;

ExprList = Expr.e
         | Expr.e COMMA ExprList.l
         ;
         
Value = ID.i
      | Value.v OPENBRACKETS Expr.e CLOSEBRACKETS
      | Value.v DOT ID.i
      ;